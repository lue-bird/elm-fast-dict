[{"name":"FastDict","comment":" A dictionary mapping unique keys to values. The keys can be any comparable\ntype. This includes `Int`, `Float`, `Time`, `Char`, `String`, and tuples or\nlists of comparable types.\n\nInsert, remove, and query operations all take _O(log n)_ time.\n\n\n# Dictionaries\n\n@docs Dict\n\n\n# Build\n\n@docs empty, singleton, insert, update, remove\n\n\n# Query\n\n@docs isEmpty, member, get, size, equals\n\n\n# Min / Max\n\n@docs getMinKey, getMin, getMaxKey, getMax\n\n@docs popMin, popMax\n\n\n# Lists\n\n@docs keys, values, toList, fromList\n\n\n# Transform\n\n@docs map, foldl, foldr, filter, partition\n\n\n# Combine\n\n@docs union, intersect, diff, merge\n\n\n# Interoperability\n\n@docs toCoreDict, fromCoreDict\n\n","unions":[],"aliases":[{"name":"Dict","comment":" A dictionary of keys and values. So a `Dict String User` is a dictionary\nthat lets you look up a `String` (such as user names) and find the associated\n`User`.\n\n    import FastDict as Dict exposing (Dict)\n\n    users : Dict String User\n    users =\n        Dict.fromList\n            [ ( \"Alice\", User \"Alice\" 28 1.65 )\n            , ( \"Bob\", User \"Bob\" 19 1.82 )\n            , ( \"Chuck\", User \"Chuck\" 33 1.75 )\n            ]\n\n    type alias User =\n        { name : String\n        , age : Int\n        , height : Float\n        }\n\n","args":["k","v"],"type":"Internal.Dict k v"}],"values":[{"name":"diff","comment":" Keep a key-value pair when its key does not appear in the second dictionary.\n","type":"FastDict.Dict comparable a -> FastDict.Dict comparable b -> FastDict.Dict comparable a"},{"name":"empty","comment":" Create an empty dictionary.\n","type":"FastDict.Dict k v"},{"name":"equals","comment":" Determine if two dictionaries are equal. This is needed because the structure could be different depending on insertion order.\n","type":"FastDict.Dict comparable v -> FastDict.Dict comparable v -> Basics.Bool"},{"name":"filter","comment":" Keep only the key-value pairs that pass the given test.\n","type":"(comparable -> v -> Basics.Bool) -> FastDict.Dict comparable v -> FastDict.Dict comparable v"},{"name":"foldl","comment":" Fold over the key-value pairs in a dictionary from lowest key to highest key.\n\n    getAges : Dict String Int -> List Int\n    getAges usersDict =\n        FastDict.foldl addAge [] usersDict\n\n    addAge : String -> Int -> List Int -> List Int\n    addAge _ age ages =\n        age :: ages\n\n    users : Dict String Int\n    users =\n        FastDict.fromList\n            [ ( \"Abe\", 28 )\n            , ( \"Beatrix\", 19 )\n            , ( \"Charlotte\", 33 )\n            ]\n\n    -- Note that the _fold_ is from lowest to highest,\n    -- but because we're adding items to the beginning of the list\n    -- the result will be from highest to lowest.\n\n    getAges users\n    --> [ 33, 19, 28 ]\n\n","type":"(k -> v -> b -> b) -> b -> FastDict.Dict k v -> b"},{"name":"foldr","comment":" Fold over the key-value pairs in a dictionary from highest key to lowest key.\n\n    getAges : Dict String Int -> List Int\n    getAges usersDict =\n        FastDict.foldr addAge [] usersDict\n\n    addAge : String -> Int -> List Int -> List Int\n    addAge _ age ages =\n        age :: ages\n\n    users : Dict String Int\n    users =\n        FastDict.fromList\n            [ ( \"Abe\", 28 )\n            , ( \"Beatrix\", 19 )\n            , ( \"Charlotte\", 33 )\n            ]\n\n    -- Note that the _fold_ is from highest to lowest,\n    -- but because we're adding items to the beginning of the list\n    -- the result will be from lowest to highest.\n\n    getAges users\n    --> [ 28, 19, 33 ]\n\n","type":"(k -> v -> b -> b) -> b -> FastDict.Dict k v -> b"},{"name":"fromCoreDict","comment":" Convert the dictionary from an equivalent one from elm/core.\n","type":"Dict.Dict comparable v -> FastDict.Dict comparable v"},{"name":"fromList","comment":" Convert an association list into a dictionary.\n","type":"List.List ( comparable, v ) -> FastDict.Dict comparable v"},{"name":"get","comment":" Get the value associated with a key. If the key is not found, return\n`Nothing`. This is useful when you are not sure if a key will be in the\ndictionary.\n\n    animals : Dict String String\n    animals =\n        fromList [ (\"Tom\", \"Cat\"), (\"Jerry\", \"Mouse\") ]\n\n    get \"Tom\"   animals\n    --> Just \"Cat\"\n\n    get \"Jerry\" animals\n    --> Just \"Mouse\"\n\n    get \"Spike\" animals\n    --> Nothing\n\n","type":"comparable -> FastDict.Dict comparable v -> Maybe.Maybe v"},{"name":"getMax","comment":" Gets the key-value pair with the biggest key.\n\n    [ ( 1, 'z' ), ( 2, 'a' ) ]\n        |> fromList\n        |> getMax\n    --> Just ( 2, 'a' )\n\n\n    empty\n        |> getMax\n    --> Nothing\n\n","type":"FastDict.Dict k v -> Maybe.Maybe ( k, v )"},{"name":"getMaxKey","comment":" Gets the biggest key in the dictionary.\n\n    [ ( 1, 'z' ), ( 2, 'a' ) ]\n        |> fromList\n        |> getMaxKey\n    --> Just 2\n\n\n    empty\n        |> getMaxKey\n    --> Nothing\n\n","type":"FastDict.Dict k v -> Maybe.Maybe k"},{"name":"getMin","comment":" Gets the key-value pair with the smallest key.\n\n    [ ( 1, 'z' ), ( 2, 'a' ) ]\n        |> fromList\n        |> getMin\n    --> Just ( 1, 'z' )\n\n\n    empty\n        |> getMin\n    --> Nothing\n\n","type":"FastDict.Dict k v -> Maybe.Maybe ( k, v )"},{"name":"getMinKey","comment":" Gets the smallest key in the dictionary.\n\n    [ ( 1, 'z' ), ( 2, 'a' ) ]\n        |> fromList\n        |> getMinKey\n    --> Just 1\n\n\n    empty\n        |> getMinKey\n    --> Nothing\n\n","type":"FastDict.Dict k v -> Maybe.Maybe k"},{"name":"insert","comment":" Insert a key-value pair into a dictionary. Replaces value when there is\na collision.\n","type":"comparable -> v -> FastDict.Dict comparable v -> FastDict.Dict comparable v"},{"name":"intersect","comment":" Keep a key-value pair when its key appears in the second dictionary.\nPreference is given to values in the first dictionary.\n","type":"FastDict.Dict comparable v -> FastDict.Dict comparable v -> FastDict.Dict comparable v"},{"name":"isEmpty","comment":" Determine if a dictionary is empty.\n\n    isEmpty empty\n    --> True\n\n","type":"FastDict.Dict k v -> Basics.Bool"},{"name":"keys","comment":" Get all of the keys in a dictionary, sorted from lowest to highest.\n\n    keys (fromList [ ( 0, \"Alice\" ), ( 1, \"Bob\" ) ])\n    --> [ 0, 1 ]\n\n","type":"FastDict.Dict k v -> List.List k"},{"name":"map","comment":" Apply a function to all values in a dictionary.\n","type":"(k -> a -> b) -> FastDict.Dict k a -> FastDict.Dict k b"},{"name":"member","comment":" Determine if a key is in a dictionary.\n","type":"comparable -> FastDict.Dict comparable v -> Basics.Bool"},{"name":"merge","comment":" The most general way of combining two dictionaries. You provide three\naccumulators for when a given key appears:\n\n1.  Only in the left dictionary.\n2.  In both dictionaries.\n3.  Only in the right dictionary.\n\nYou then traverse all the keys from lowest to highest, building up whatever\nyou want.\n\n","type":"(comparable -> a -> result -> result) -> (comparable -> a -> b -> result -> result) -> (comparable -> b -> result -> result) -> FastDict.Dict comparable a -> FastDict.Dict comparable b -> result -> result"},{"name":"partition","comment":" Partition a dictionary according to some test. The first dictionary\ncontains all key-value pairs which passed the test, and the second contains\nthe pairs that did not.\n","type":"(comparable -> v -> Basics.Bool) -> FastDict.Dict comparable v -> ( FastDict.Dict comparable v, FastDict.Dict comparable v )"},{"name":"popMax","comment":" Removes the key-value pair with the biggest key from the dictionary, and returns it.\n\n    [ ( 1, 'z' ), ( 2, 'a' ) ]\n        |> fromList\n        |> popMax\n    --> Just ( ( 2, 'a' ), fromList [ ( 1, 'z' ) ] )\n\n\n    empty\n        |> popMax\n    --> Nothing\n\n","type":"FastDict.Dict comparable v -> Maybe.Maybe ( ( comparable, v ), FastDict.Dict comparable v )"},{"name":"popMin","comment":" Removes the key-value pair with the smallest key from the dictionary, and returns it.\n\n    [ ( 1, 'z' ), ( 2, 'a' ) ]\n        |> fromList\n        |> popMin\n    --> Just ( ( 1, 'z' ), fromList [ ( 2, 'a' ) ] )\n\n\n    empty\n        |> popMin\n    --> Nothing\n\n","type":"FastDict.Dict comparable v -> Maybe.Maybe ( ( comparable, v ), FastDict.Dict comparable v )"},{"name":"remove","comment":" Remove a key-value pair from a dictionary. If the key is not found,\nno changes are made.\n","type":"comparable -> FastDict.Dict comparable v -> FastDict.Dict comparable v"},{"name":"singleton","comment":" Create a dictionary with one key-value pair.\n","type":"comparable -> v -> FastDict.Dict comparable v"},{"name":"size","comment":" Determine the number of key-value pairs in the dictionary.\n","type":"FastDict.Dict k v -> Basics.Int"},{"name":"toCoreDict","comment":" Convert the dictionary into an equivalent one from elm/core.\n","type":"FastDict.Dict comparable v -> Dict.Dict comparable v"},{"name":"toList","comment":" Convert a dictionary into an association list of key-value pairs, sorted by keys.\n","type":"FastDict.Dict k v -> List.List ( k, v )"},{"name":"union","comment":" Combine two dictionaries. If there is a collision, preference is given\nto the first dictionary.\n","type":"FastDict.Dict comparable v -> FastDict.Dict comparable v -> FastDict.Dict comparable v"},{"name":"update","comment":" Update the value of a dictionary for a specific key with a given function.\n","type":"comparable -> (Maybe.Maybe v -> Maybe.Maybe v) -> FastDict.Dict comparable v -> FastDict.Dict comparable v"},{"name":"values","comment":" Get all of the values in a dictionary, in the order of their keys.\n\n    values (fromList [ ( 0, \"Alice\" ), ( 1, \"Bob\" ) ])\n    --> [ \"Alice\", \"Bob\" ]\n\n","type":"FastDict.Dict k v -> List.List v"}],"binops":[]}]